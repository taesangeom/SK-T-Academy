# 정리!!!!!
## DFS / BFS 모두 가능한 문제
==> 본인이 편한 스타일로 선택해서 하시면 됨!!!!!

## DFS 사용이 가능하다!!! ==> Stack!!!! --> 재귀함수를 써도 됨!!!
1) 정의대로 탐색 기본으로 구현: append(), pop()
2) 기능 중심으로 재귀함수로 구현이 가능함!!!

## BFS 사용이 가능하다!! ==> queue ==> deque
==> 거리, 출발점에 순서 중요할 떄
: 출발점에서 뭔가 점진적으로 진행을 해야하는 경우들의 상황!!!
==> 최단거리 문제로 일반화 : 다익스트라 알고리즘!!!!!
(거리가 1로 일정하거나 하는 간단한 경우 : BFS로 처리가 가능!!)
==> 속도 이슈 : deque : append(), popleft()
주의!!!) 절대로 재귀함수를 사용하시면 안 됨!!!!!!!!

기본적인 탐색에 대해서 정확히 알 면
중간 킬러 문항들을 많이 해쳐나갈 수 있음!!
단, 안다고 해결은 안 됨!!!
==> 주어진 상황에 유연하게 대처/ 구현을 할 수 있어야 함!!!!!!!!
# 최단거리  
다익스트라: 결국 구조는 다 비슷하다 . -> distance INF 처리, 그외 가중치 담긴 graph 등, heapq, while 등 구조는 동일하다 .  


# 최단거리 문제 : 꼭 최단 거리만 아니라, 요금. 다른 대상일 수 있음!!
              그 중에서 제일 최소값에 대한 것을 찾는 것!!!!
               정렬이랑은 조금은 다름!!!
# 다익스트라알고리즘 : BFS --> 응용한 방식
                  : 기본 알고리즘 코드 방식
                     ==> 할 일에 대해서 큐!!! ( == BFS와 유사 방식!! )
                        우선순위 큐!!!!!!!!! ( 지금 결과상 제일 우선순위!!)
                                                 [ 지금 중에서 제일 최소길이]
                    ==> 기본 코드 방식 유사 BFS
                          - 시작점에 대해서 처리(할 일에 등록, 한 일 처리)
                         - 하나씩 할 일을 꺼내는거!!!
                           heapq :
                          - 할 일이 있으면, 여기서 더 한단계 가서..
                            비용을 계산해서 , 지금까지 비용보다 더 절감되면
                            ==> 더 거기서 가서 해봐 : 할 일에 추가!!!!
# ++
